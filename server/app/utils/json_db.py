import json
import os
import uuid
import shutil
from datetime import datetime
from typing import List, Dict, Any, Optional
from fastapi import UploadFile

# --- Configuration ---
# Define paths for our JSON database and image uploads
DB_DIR = "app/db"
UPLOADS_DIR = "app/uploads"

# Define paths for our three new JSON database files
PARENTS_DB_PATH = os.path.join(DB_DIR, "parents.json")
VOLUNTEERS_DB_PATH = os.path.join(DB_DIR, "volunteers.json")
CHILDREN_DB_PATH = os.path.join(DB_DIR, "children.json")
USERS_DB_PATH = os.path.join(DB_DIR, "users.json")

# --- Initialization ---
# Ensure database and upload directories exist on startup
os.makedirs(DB_DIR, exist_ok=True)
os.makedirs(UPLOADS_DIR, exist_ok=True)

# Ensure all FOUR DB files exist
for path in [PARENTS_DB_PATH, VOLUNTEERS_DB_PATH, CHILDREN_DB_PATH, USERS_DB_PATH]:
    if not os.path.exists(path):
        with open(path, "w") as f:
            json.dump([], f) # Start with an empty list

# --- Internal Helper Functions ---
def _get_db_path(collection_name: str) -> str:
    """Returns the correct file path for a given collection name."""
    if collection_name == "parents":
        return PARENTS_DB_PATH
    elif collection_name == "volunteers":
        return VOLUNTEERS_DB_PATH
    elif collection_name == "children":
        return CHILDREN_DB_PATH
    # --- NEW ---
    elif collection_name == "users":
        return USERS_DB_PATH
    else:
        raise ValueError(f"Unknown collection name: {collection_name}")

def _load_db(collection_name: str) -> List[Dict[str, Any]]:
    """Loads the entire database from the correct JSON file."""
    db_path = _get_db_path(collection_name)
    try:
        with open(db_path, "r") as f:
            data = json.load(f)
            if not isinstance(data, list):
                return [] # Ensure it's a list, even if file is corrupt
            return data
    except (json.JSONDecodeError, FileNotFoundError):
        return [] # Return empty list if file is empty or corrupt

def _save_db(data: List[Dict[str, Any]], collection_name: str):
    """Saves the entire database list back to the correct JSON file."""
    db_path = _get_db_path(collection_name)
    with open(db_path, "w") as f:
        # default=str ensures datetimes are saved in ISO format
        json.dump(data, f, indent=4, default=str)

# --- Public Database Functions ---

async def save_image_file(file: UploadFile, submission_id: str) -> str:
    """
    Saves an uploaded image file to the local filesystem.
    Returns the relative web-accessible path to the image.
    (This function remains unchanged)
    """
    file_extension = os.path.splitext(file.filename)[-1] or ".jpg"
    filename = f"{submission_id}{file_extension}"
    file_path = os.path.join(UPLOADS_DIR, filename)
    
    try:
        await file.seek(0)
        with open(file_path, "wb") as buffer:
            shutil.copyfileobj(file.file, buffer)
    finally:
        await file.close()
        
    return f"/uploads/{filename}"

def insert_submission(doc: Dict[str, Any], collection_name: str) -> str:
    """
    Inserts a new submission document into the specified JSON file.
    Uses the _id already in the doc (generated by Pydantic).
    """
    data = _load_db(collection_name)
    
   # Add timestamps (Pydantic model already created _id)
    # --- UPDATED: Only add created_at if it's not the users collection ---
    if collection_name != "users":
        doc["created_at"] = datetime.utcnow().isoformat()
    
    data.append(doc)
    _save_db(data, collection_name)
    
    return doc["_id"] # Return the ID

def find_submission(id_str: str, collection_name: str) -> Optional[Dict[str, Any]]:
    """Finds a single submission by its _id in the specified collection."""
    data = _load_db(collection_name)
    for item in data:
        if item.get("_id") == id_str:
            return item
    return None

# --------------------------------------------------------
# --- NEW ---
def find_user_by_id(user_id: str) -> Optional[Dict[str, Any]]:
    """Finds a user by their _id."""
    data = _load_db("users")
    for user in data:
        if user.get("_id") == user_id:
            return user
    return None


# --- NEW ---
def find_reports_by_user_id(user_id: str) -> List[Dict[str, Any]]:
    """Finds all reports (parent or volunteer) submitted by a user."""
    reports = []
    
    # Check parents
    parent_data = _load_db("parents")
    for report in parent_data:
        if report.get("user_id") == user_id:
            reports.append(report)
            
    # Check volunteers
    volunteer_data = _load_db("volunteers")
    for report in volunteer_data:
        if report.get("user_id") == user_id:
            reports.append(report)
            
    return reports


# --- NEW ---
def find_user_by_identifier(identifier: str) -> Optional[Dict[str, Any]]:
    """Finds a user by username, email, or phone."""
    data = _load_db("users")
    for user in data:
        if user.get("username") == identifier or \
           user.get("email") == identifier or \
           user.get("phone") == identifier:
            return user
    return None


# --- NEW: Generic User Update Function ---
def update_user(user_id: str, updates: Dict[str, Any]):
    """
    Finds a user by ID and updates their record.
    This is separate from update_submission.
    """
    data = _load_db("users")
    
    found = False
    for i, item in enumerate(data):
        if item.get("_id") == user_id:
            # Merge the updates into the existing item
            data[i].update(updates) 
            found = True
            break       
    if found:
        _save_db(data, "users")
    
    return found


# ------------------------------------------------
def update_submission(id_str: str, updates: Dict[str, Any], collection_name: str):
    """
    Finds a submission by ID in the specified collection and updates it.
    """
    data = _load_db(collection_name)
    
    found = False
    for i, item in enumerate(data):
        if item.get("_id") == id_str:
            # Merge the updates into the existing item
            # This is smart, it can update nested keys like 'match'
            # Note: This is a shallow merge on top-level keys.
            # To update a nested key, pass the entire top-level key:
            # e.g., updates = {"match": {"score": 0.9, ...}}
            data[i].update(updates) 
            found = True
            break
            
    if found:
        _save_db(data, collection_name)
    
    return found

def list_submissions(collection_name: str) -> List[Dict[str, Any]]:
    """Returns all submissions from the specified collection."""
    return _load_db(collection_name)